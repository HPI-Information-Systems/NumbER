# coding: utf-8

"""
    RCSB RESTful API

    Provides programmatic access to information and annotations stored in the Protein Data Bank. <br>Models are generated from JSON schema version: <b>1.40.0</b>. <br>API services deployed on: Sun, 2 Apr 2023 21:44:46 -0700  # noqa: E501

    OpenAPI spec version: 1.40.0
    Contact: info@rcsb.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class ChemComp(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'formula': 'str',
        'formula_weight': 'float',
        'id': 'str',
        'mon_nstd_parent_comp_id': 'list[str]',
        'name': 'str',
        'one_letter_code': 'str',
        'pdbx_ambiguous_flag': 'str',
        'pdbx_formal_charge': 'int',
        'pdbx_initial_date': 'datetime',
        'pdbx_modified_date': 'datetime',
        'pdbx_processing_site': 'str',
        'pdbx_release_status': 'str',
        'pdbx_replaced_by': 'str',
        'pdbx_replaces': 'str',
        'pdbx_subcomponent_list': 'str',
        'three_letter_code': 'str',
        'type': 'str'
    }

    attribute_map = {
        'formula': 'formula',
        'formula_weight': 'formula_weight',
        'id': 'id',
        'mon_nstd_parent_comp_id': 'mon_nstd_parent_comp_id',
        'name': 'name',
        'one_letter_code': 'one_letter_code',
        'pdbx_ambiguous_flag': 'pdbx_ambiguous_flag',
        'pdbx_formal_charge': 'pdbx_formal_charge',
        'pdbx_initial_date': 'pdbx_initial_date',
        'pdbx_modified_date': 'pdbx_modified_date',
        'pdbx_processing_site': 'pdbx_processing_site',
        'pdbx_release_status': 'pdbx_release_status',
        'pdbx_replaced_by': 'pdbx_replaced_by',
        'pdbx_replaces': 'pdbx_replaces',
        'pdbx_subcomponent_list': 'pdbx_subcomponent_list',
        'three_letter_code': 'three_letter_code',
        'type': 'type'
    }

    def __init__(self, formula=None, formula_weight=None, id=None, mon_nstd_parent_comp_id=None, name=None, one_letter_code=None, pdbx_ambiguous_flag=None, pdbx_formal_charge=None, pdbx_initial_date=None, pdbx_modified_date=None, pdbx_processing_site=None, pdbx_release_status=None, pdbx_replaced_by=None, pdbx_replaces=None, pdbx_subcomponent_list=None, three_letter_code=None, type=None):  # noqa: E501
        """ChemComp - a model defined in Swagger"""  # noqa: E501
        self._formula = None
        self._formula_weight = None
        self._id = None
        self._mon_nstd_parent_comp_id = None
        self._name = None
        self._one_letter_code = None
        self._pdbx_ambiguous_flag = None
        self._pdbx_formal_charge = None
        self._pdbx_initial_date = None
        self._pdbx_modified_date = None
        self._pdbx_processing_site = None
        self._pdbx_release_status = None
        self._pdbx_replaced_by = None
        self._pdbx_replaces = None
        self._pdbx_subcomponent_list = None
        self._three_letter_code = None
        self._type = None
        self.discriminator = None
        if formula is not None:
            self.formula = formula
        if formula_weight is not None:
            self.formula_weight = formula_weight
        self.id = id
        if mon_nstd_parent_comp_id is not None:
            self.mon_nstd_parent_comp_id = mon_nstd_parent_comp_id
        if name is not None:
            self.name = name
        if one_letter_code is not None:
            self.one_letter_code = one_letter_code
        if pdbx_ambiguous_flag is not None:
            self.pdbx_ambiguous_flag = pdbx_ambiguous_flag
        if pdbx_formal_charge is not None:
            self.pdbx_formal_charge = pdbx_formal_charge
        if pdbx_initial_date is not None:
            self.pdbx_initial_date = pdbx_initial_date
        if pdbx_modified_date is not None:
            self.pdbx_modified_date = pdbx_modified_date
        if pdbx_processing_site is not None:
            self.pdbx_processing_site = pdbx_processing_site
        if pdbx_release_status is not None:
            self.pdbx_release_status = pdbx_release_status
        if pdbx_replaced_by is not None:
            self.pdbx_replaced_by = pdbx_replaced_by
        if pdbx_replaces is not None:
            self.pdbx_replaces = pdbx_replaces
        if pdbx_subcomponent_list is not None:
            self.pdbx_subcomponent_list = pdbx_subcomponent_list
        if three_letter_code is not None:
            self.three_letter_code = three_letter_code
        if type is not None:
            self.type = type

    @property
    def formula(self):
        """Gets the formula of this ChemComp.  # noqa: E501

        The formula for the chemical component. Formulae are written  according to the following rules:   (1) Only recognized element symbols may be used.   (2) Each element symbol is followed by a 'count' number. A count     of '1' may be omitted.   (3) A space or parenthesis must separate each cluster of     (element symbol + count), but in general parentheses are     not used.   (4) The order of elements depends on whether carbon is     present or not. If carbon is present, the order should be:     C, then H, then the other elements in alphabetical order     of their symbol. If carbon is not present, the elements     are listed purely in alphabetic order of their symbol. This     is the 'Hill' system used by Chemical Abstracts.  # noqa: E501

        :return: The formula of this ChemComp.  # noqa: E501
        :rtype: str
        """
        return self._formula

    @formula.setter
    def formula(self, formula):
        """Sets the formula of this ChemComp.

        The formula for the chemical component. Formulae are written  according to the following rules:   (1) Only recognized element symbols may be used.   (2) Each element symbol is followed by a 'count' number. A count     of '1' may be omitted.   (3) A space or parenthesis must separate each cluster of     (element symbol + count), but in general parentheses are     not used.   (4) The order of elements depends on whether carbon is     present or not. If carbon is present, the order should be:     C, then H, then the other elements in alphabetical order     of their symbol. If carbon is not present, the elements     are listed purely in alphabetic order of their symbol. This     is the 'Hill' system used by Chemical Abstracts.  # noqa: E501

        :param formula: The formula of this ChemComp.  # noqa: E501
        :type: str
        """

        self._formula = formula

    @property
    def formula_weight(self):
        """Gets the formula_weight of this ChemComp.  # noqa: E501

        Formula mass of the chemical component.  # noqa: E501

        :return: The formula_weight of this ChemComp.  # noqa: E501
        :rtype: float
        """
        return self._formula_weight

    @formula_weight.setter
    def formula_weight(self, formula_weight):
        """Sets the formula_weight of this ChemComp.

        Formula mass of the chemical component.  # noqa: E501

        :param formula_weight: The formula_weight of this ChemComp.  # noqa: E501
        :type: float
        """

        self._formula_weight = formula_weight

    @property
    def id(self):
        """Gets the id of this ChemComp.  # noqa: E501

        The value of _chem_comp.id must uniquely identify each item in  the CHEM_COMP list.   For protein polymer entities, this is the three-letter code for  the amino acid.   For nucleic acid polymer entities, this is the one-letter code  for the base.  # noqa: E501

        :return: The id of this ChemComp.  # noqa: E501
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this ChemComp.

        The value of _chem_comp.id must uniquely identify each item in  the CHEM_COMP list.   For protein polymer entities, this is the three-letter code for  the amino acid.   For nucleic acid polymer entities, this is the one-letter code  for the base.  # noqa: E501

        :param id: The id of this ChemComp.  # noqa: E501
        :type: str
        """
        if id is None:
            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501

        self._id = id

    @property
    def mon_nstd_parent_comp_id(self):
        """Gets the mon_nstd_parent_comp_id of this ChemComp.  # noqa: E501

        The identifier for the parent component of the nonstandard  component. May be be a comma separated list if this component  is derived from multiple components.   Items in this indirectly point to _chem_comp.id in  the CHEM_COMP category.  # noqa: E501

        :return: The mon_nstd_parent_comp_id of this ChemComp.  # noqa: E501
        :rtype: list[str]
        """
        return self._mon_nstd_parent_comp_id

    @mon_nstd_parent_comp_id.setter
    def mon_nstd_parent_comp_id(self, mon_nstd_parent_comp_id):
        """Sets the mon_nstd_parent_comp_id of this ChemComp.

        The identifier for the parent component of the nonstandard  component. May be be a comma separated list if this component  is derived from multiple components.   Items in this indirectly point to _chem_comp.id in  the CHEM_COMP category.  # noqa: E501

        :param mon_nstd_parent_comp_id: The mon_nstd_parent_comp_id of this ChemComp.  # noqa: E501
        :type: list[str]
        """

        self._mon_nstd_parent_comp_id = mon_nstd_parent_comp_id

    @property
    def name(self):
        """Gets the name of this ChemComp.  # noqa: E501

        The full name of the component.  # noqa: E501

        :return: The name of this ChemComp.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this ChemComp.

        The full name of the component.  # noqa: E501

        :param name: The name of this ChemComp.  # noqa: E501
        :type: str
        """

        self._name = name

    @property
    def one_letter_code(self):
        """Gets the one_letter_code of this ChemComp.  # noqa: E501

        For standard polymer components, the one-letter code for  the component.   For non-standard polymer components, the  one-letter code for parent component if this exists;  otherwise, the one-letter code should be given as 'X'.   Components that derived from multiple parents components  are described by a sequence of one-letter-codes.  # noqa: E501

        :return: The one_letter_code of this ChemComp.  # noqa: E501
        :rtype: str
        """
        return self._one_letter_code

    @one_letter_code.setter
    def one_letter_code(self, one_letter_code):
        """Sets the one_letter_code of this ChemComp.

        For standard polymer components, the one-letter code for  the component.   For non-standard polymer components, the  one-letter code for parent component if this exists;  otherwise, the one-letter code should be given as 'X'.   Components that derived from multiple parents components  are described by a sequence of one-letter-codes.  # noqa: E501

        :param one_letter_code: The one_letter_code of this ChemComp.  # noqa: E501
        :type: str
        """

        self._one_letter_code = one_letter_code

    @property
    def pdbx_ambiguous_flag(self):
        """Gets the pdbx_ambiguous_flag of this ChemComp.  # noqa: E501

        A preliminary classification used by PDB to indicate  that the chemistry of this component while described  as clearly as possible is still ambiguous.  Software  tools may not be able to process this component  definition.  # noqa: E501

        :return: The pdbx_ambiguous_flag of this ChemComp.  # noqa: E501
        :rtype: str
        """
        return self._pdbx_ambiguous_flag

    @pdbx_ambiguous_flag.setter
    def pdbx_ambiguous_flag(self, pdbx_ambiguous_flag):
        """Sets the pdbx_ambiguous_flag of this ChemComp.

        A preliminary classification used by PDB to indicate  that the chemistry of this component while described  as clearly as possible is still ambiguous.  Software  tools may not be able to process this component  definition.  # noqa: E501

        :param pdbx_ambiguous_flag: The pdbx_ambiguous_flag of this ChemComp.  # noqa: E501
        :type: str
        """

        self._pdbx_ambiguous_flag = pdbx_ambiguous_flag

    @property
    def pdbx_formal_charge(self):
        """Gets the pdbx_formal_charge of this ChemComp.  # noqa: E501

        The net integer charge assigned to this component. This is the  formal charge assignment normally found in chemical diagrams.  # noqa: E501

        :return: The pdbx_formal_charge of this ChemComp.  # noqa: E501
        :rtype: int
        """
        return self._pdbx_formal_charge

    @pdbx_formal_charge.setter
    def pdbx_formal_charge(self, pdbx_formal_charge):
        """Sets the pdbx_formal_charge of this ChemComp.

        The net integer charge assigned to this component. This is the  formal charge assignment normally found in chemical diagrams.  # noqa: E501

        :param pdbx_formal_charge: The pdbx_formal_charge of this ChemComp.  # noqa: E501
        :type: int
        """

        self._pdbx_formal_charge = pdbx_formal_charge

    @property
    def pdbx_initial_date(self):
        """Gets the pdbx_initial_date of this ChemComp.  # noqa: E501

        Date component was added to database.  # noqa: E501

        :return: The pdbx_initial_date of this ChemComp.  # noqa: E501
        :rtype: datetime
        """
        return self._pdbx_initial_date

    @pdbx_initial_date.setter
    def pdbx_initial_date(self, pdbx_initial_date):
        """Sets the pdbx_initial_date of this ChemComp.

        Date component was added to database.  # noqa: E501

        :param pdbx_initial_date: The pdbx_initial_date of this ChemComp.  # noqa: E501
        :type: datetime
        """

        self._pdbx_initial_date = pdbx_initial_date

    @property
    def pdbx_modified_date(self):
        """Gets the pdbx_modified_date of this ChemComp.  # noqa: E501

        Date component was last modified.  # noqa: E501

        :return: The pdbx_modified_date of this ChemComp.  # noqa: E501
        :rtype: datetime
        """
        return self._pdbx_modified_date

    @pdbx_modified_date.setter
    def pdbx_modified_date(self, pdbx_modified_date):
        """Sets the pdbx_modified_date of this ChemComp.

        Date component was last modified.  # noqa: E501

        :param pdbx_modified_date: The pdbx_modified_date of this ChemComp.  # noqa: E501
        :type: datetime
        """

        self._pdbx_modified_date = pdbx_modified_date

    @property
    def pdbx_processing_site(self):
        """Gets the pdbx_processing_site of this ChemComp.  # noqa: E501

        This data item identifies the deposition site that processed  this chemical component defintion.  # noqa: E501

        :return: The pdbx_processing_site of this ChemComp.  # noqa: E501
        :rtype: str
        """
        return self._pdbx_processing_site

    @pdbx_processing_site.setter
    def pdbx_processing_site(self, pdbx_processing_site):
        """Sets the pdbx_processing_site of this ChemComp.

        This data item identifies the deposition site that processed  this chemical component defintion.  # noqa: E501

        :param pdbx_processing_site: The pdbx_processing_site of this ChemComp.  # noqa: E501
        :type: str
        """
        allowed_values = ["EBI", "PDBC", "PDBE", "PDBJ", "RCSB"]  # noqa: E501
        if pdbx_processing_site not in allowed_values:
            raise ValueError(
                "Invalid value for `pdbx_processing_site` ({0}), must be one of {1}"  # noqa: E501
                .format(pdbx_processing_site, allowed_values)
            )

        self._pdbx_processing_site = pdbx_processing_site

    @property
    def pdbx_release_status(self):
        """Gets the pdbx_release_status of this ChemComp.  # noqa: E501

        This data item holds the current release status for the component.  # noqa: E501

        :return: The pdbx_release_status of this ChemComp.  # noqa: E501
        :rtype: str
        """
        return self._pdbx_release_status

    @pdbx_release_status.setter
    def pdbx_release_status(self, pdbx_release_status):
        """Sets the pdbx_release_status of this ChemComp.

        This data item holds the current release status for the component.  # noqa: E501

        :param pdbx_release_status: The pdbx_release_status of this ChemComp.  # noqa: E501
        :type: str
        """
        allowed_values = ["DEL", "HOLD", "HPUB", "OBS", "REF_ONLY", "REL"]  # noqa: E501
        if pdbx_release_status not in allowed_values:
            raise ValueError(
                "Invalid value for `pdbx_release_status` ({0}), must be one of {1}"  # noqa: E501
                .format(pdbx_release_status, allowed_values)
            )

        self._pdbx_release_status = pdbx_release_status

    @property
    def pdbx_replaced_by(self):
        """Gets the pdbx_replaced_by of this ChemComp.  # noqa: E501

        Identifies the _chem_comp.id of the component that  has replaced this component.  # noqa: E501

        :return: The pdbx_replaced_by of this ChemComp.  # noqa: E501
        :rtype: str
        """
        return self._pdbx_replaced_by

    @pdbx_replaced_by.setter
    def pdbx_replaced_by(self, pdbx_replaced_by):
        """Sets the pdbx_replaced_by of this ChemComp.

        Identifies the _chem_comp.id of the component that  has replaced this component.  # noqa: E501

        :param pdbx_replaced_by: The pdbx_replaced_by of this ChemComp.  # noqa: E501
        :type: str
        """

        self._pdbx_replaced_by = pdbx_replaced_by

    @property
    def pdbx_replaces(self):
        """Gets the pdbx_replaces of this ChemComp.  # noqa: E501

        Identifies the _chem_comp.id's of the components  which have been replaced by this component.  Multiple id codes should be separated by commas.  # noqa: E501

        :return: The pdbx_replaces of this ChemComp.  # noqa: E501
        :rtype: str
        """
        return self._pdbx_replaces

    @pdbx_replaces.setter
    def pdbx_replaces(self, pdbx_replaces):
        """Sets the pdbx_replaces of this ChemComp.

        Identifies the _chem_comp.id's of the components  which have been replaced by this component.  Multiple id codes should be separated by commas.  # noqa: E501

        :param pdbx_replaces: The pdbx_replaces of this ChemComp.  # noqa: E501
        :type: str
        """

        self._pdbx_replaces = pdbx_replaces

    @property
    def pdbx_subcomponent_list(self):
        """Gets the pdbx_subcomponent_list of this ChemComp.  # noqa: E501

        The list of subcomponents contained in this component.  # noqa: E501

        :return: The pdbx_subcomponent_list of this ChemComp.  # noqa: E501
        :rtype: str
        """
        return self._pdbx_subcomponent_list

    @pdbx_subcomponent_list.setter
    def pdbx_subcomponent_list(self, pdbx_subcomponent_list):
        """Sets the pdbx_subcomponent_list of this ChemComp.

        The list of subcomponents contained in this component.  # noqa: E501

        :param pdbx_subcomponent_list: The pdbx_subcomponent_list of this ChemComp.  # noqa: E501
        :type: str
        """

        self._pdbx_subcomponent_list = pdbx_subcomponent_list

    @property
    def three_letter_code(self):
        """Gets the three_letter_code of this ChemComp.  # noqa: E501

        For standard polymer components, the common three-letter code for  the component.   Non-standard polymer components and non-polymer  components are also assigned three-letter-codes.   For ambiguous polymer components three-letter code should  be given as 'UNK'.  Ambiguous ions are assigned the code 'UNX'.  Ambiguous non-polymer components are assigned the code 'UNL'.  # noqa: E501

        :return: The three_letter_code of this ChemComp.  # noqa: E501
        :rtype: str
        """
        return self._three_letter_code

    @three_letter_code.setter
    def three_letter_code(self, three_letter_code):
        """Sets the three_letter_code of this ChemComp.

        For standard polymer components, the common three-letter code for  the component.   Non-standard polymer components and non-polymer  components are also assigned three-letter-codes.   For ambiguous polymer components three-letter code should  be given as 'UNK'.  Ambiguous ions are assigned the code 'UNX'.  Ambiguous non-polymer components are assigned the code 'UNL'.  # noqa: E501

        :param three_letter_code: The three_letter_code of this ChemComp.  # noqa: E501
        :type: str
        """

        self._three_letter_code = three_letter_code

    @property
    def type(self):
        """Gets the type of this ChemComp.  # noqa: E501

        For standard polymer components, the type of the monomer.  Note that monomers that will form polymers are of three types:  linking monomers, monomers with some type of N-terminal (or 5')  cap and monomers with some type of C-terminal (or 3') cap.  # noqa: E501

        :return: The type of this ChemComp.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this ChemComp.

        For standard polymer components, the type of the monomer.  Note that monomers that will form polymers are of three types:  linking monomers, monomers with some type of N-terminal (or 5')  cap and monomers with some type of C-terminal (or 3') cap.  # noqa: E501

        :param type: The type of this ChemComp.  # noqa: E501
        :type: str
        """
        allowed_values = ["D-beta-peptide, C-gamma linking", "D-gamma-peptide, C-delta linking", "D-peptide COOH carboxy terminus", "D-peptide NH3 amino terminus", "D-peptide linking", "D-saccharide", "D-saccharide, alpha linking", "D-saccharide, beta linking", "DNA OH 3 prime terminus", "DNA OH 5 prime terminus", "DNA linking", "L-DNA linking", "L-RNA linking", "L-beta-peptide, C-gamma linking", "L-gamma-peptide, C-delta linking", "L-peptide COOH carboxy terminus", "L-peptide NH3 amino terminus", "L-peptide linking", "L-saccharide", "L-saccharide, alpha linking", "L-saccharide, beta linking", "RNA OH 3 prime terminus", "RNA OH 5 prime terminus", "RNA linking", "non-polymer", "other", "peptide linking", "peptide-like", "saccharide"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"  # noqa: E501
                .format(type, allowed_values)
            )

        self._type = type

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(ChemComp, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ChemComp):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
