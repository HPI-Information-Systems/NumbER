# coding: utf-8

"""
    RCSB RESTful API

    Provides programmatic access to information and annotations stored in the Protein Data Bank. <br>Models are generated from JSON schema version: <b>1.40.0</b>. <br>API services deployed on: Sun, 2 Apr 2023 21:44:46 -0700  # noqa: E501

    OpenAPI spec version: 1.40.0
    Contact: info@rcsb.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class EntityPoly(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'nstd_linkage': 'str',
        'nstd_monomer': 'str',
        'pdbx_seq_one_letter_code': 'str',
        'pdbx_seq_one_letter_code_can': 'str',
        'pdbx_sequence_evidence_code': 'str',
        'pdbx_strand_id': 'str',
        'pdbx_target_identifier': 'str',
        'rcsb_artifact_monomer_count': 'int',
        'rcsb_conflict_count': 'int',
        'rcsb_deletion_count': 'int',
        'rcsb_entity_polymer_type': 'str',
        'rcsb_insertion_count': 'int',
        'rcsb_mutation_count': 'int',
        'rcsb_non_std_monomer_count': 'int',
        'rcsb_non_std_monomers': 'list[str]',
        'rcsb_prd_id': 'str',
        'rcsb_sample_sequence_length': 'int',
        'type': 'str'
    }

    attribute_map = {
        'nstd_linkage': 'nstd_linkage',
        'nstd_monomer': 'nstd_monomer',
        'pdbx_seq_one_letter_code': 'pdbx_seq_one_letter_code',
        'pdbx_seq_one_letter_code_can': 'pdbx_seq_one_letter_code_can',
        'pdbx_sequence_evidence_code': 'pdbx_sequence_evidence_code',
        'pdbx_strand_id': 'pdbx_strand_id',
        'pdbx_target_identifier': 'pdbx_target_identifier',
        'rcsb_artifact_monomer_count': 'rcsb_artifact_monomer_count',
        'rcsb_conflict_count': 'rcsb_conflict_count',
        'rcsb_deletion_count': 'rcsb_deletion_count',
        'rcsb_entity_polymer_type': 'rcsb_entity_polymer_type',
        'rcsb_insertion_count': 'rcsb_insertion_count',
        'rcsb_mutation_count': 'rcsb_mutation_count',
        'rcsb_non_std_monomer_count': 'rcsb_non_std_monomer_count',
        'rcsb_non_std_monomers': 'rcsb_non_std_monomers',
        'rcsb_prd_id': 'rcsb_prd_id',
        'rcsb_sample_sequence_length': 'rcsb_sample_sequence_length',
        'type': 'type'
    }

    def __init__(self, nstd_linkage=None, nstd_monomer=None, pdbx_seq_one_letter_code=None, pdbx_seq_one_letter_code_can=None, pdbx_sequence_evidence_code=None, pdbx_strand_id=None, pdbx_target_identifier=None, rcsb_artifact_monomer_count=None, rcsb_conflict_count=None, rcsb_deletion_count=None, rcsb_entity_polymer_type=None, rcsb_insertion_count=None, rcsb_mutation_count=None, rcsb_non_std_monomer_count=None, rcsb_non_std_monomers=None, rcsb_prd_id=None, rcsb_sample_sequence_length=None, type=None):  # noqa: E501
        """EntityPoly - a model defined in Swagger"""  # noqa: E501
        self._nstd_linkage = None
        self._nstd_monomer = None
        self._pdbx_seq_one_letter_code = None
        self._pdbx_seq_one_letter_code_can = None
        self._pdbx_sequence_evidence_code = None
        self._pdbx_strand_id = None
        self._pdbx_target_identifier = None
        self._rcsb_artifact_monomer_count = None
        self._rcsb_conflict_count = None
        self._rcsb_deletion_count = None
        self._rcsb_entity_polymer_type = None
        self._rcsb_insertion_count = None
        self._rcsb_mutation_count = None
        self._rcsb_non_std_monomer_count = None
        self._rcsb_non_std_monomers = None
        self._rcsb_prd_id = None
        self._rcsb_sample_sequence_length = None
        self._type = None
        self.discriminator = None
        if nstd_linkage is not None:
            self.nstd_linkage = nstd_linkage
        if nstd_monomer is not None:
            self.nstd_monomer = nstd_monomer
        if pdbx_seq_one_letter_code is not None:
            self.pdbx_seq_one_letter_code = pdbx_seq_one_letter_code
        if pdbx_seq_one_letter_code_can is not None:
            self.pdbx_seq_one_letter_code_can = pdbx_seq_one_letter_code_can
        if pdbx_sequence_evidence_code is not None:
            self.pdbx_sequence_evidence_code = pdbx_sequence_evidence_code
        if pdbx_strand_id is not None:
            self.pdbx_strand_id = pdbx_strand_id
        if pdbx_target_identifier is not None:
            self.pdbx_target_identifier = pdbx_target_identifier
        if rcsb_artifact_monomer_count is not None:
            self.rcsb_artifact_monomer_count = rcsb_artifact_monomer_count
        if rcsb_conflict_count is not None:
            self.rcsb_conflict_count = rcsb_conflict_count
        if rcsb_deletion_count is not None:
            self.rcsb_deletion_count = rcsb_deletion_count
        if rcsb_entity_polymer_type is not None:
            self.rcsb_entity_polymer_type = rcsb_entity_polymer_type
        if rcsb_insertion_count is not None:
            self.rcsb_insertion_count = rcsb_insertion_count
        if rcsb_mutation_count is not None:
            self.rcsb_mutation_count = rcsb_mutation_count
        if rcsb_non_std_monomer_count is not None:
            self.rcsb_non_std_monomer_count = rcsb_non_std_monomer_count
        if rcsb_non_std_monomers is not None:
            self.rcsb_non_std_monomers = rcsb_non_std_monomers
        if rcsb_prd_id is not None:
            self.rcsb_prd_id = rcsb_prd_id
        if rcsb_sample_sequence_length is not None:
            self.rcsb_sample_sequence_length = rcsb_sample_sequence_length
        if type is not None:
            self.type = type

    @property
    def nstd_linkage(self):
        """Gets the nstd_linkage of this EntityPoly.  # noqa: E501

        A flag to indicate whether the polymer contains at least  one monomer-to-monomer link different from that implied by  _entity_poly.type.  # noqa: E501

        :return: The nstd_linkage of this EntityPoly.  # noqa: E501
        :rtype: str
        """
        return self._nstd_linkage

    @nstd_linkage.setter
    def nstd_linkage(self, nstd_linkage):
        """Sets the nstd_linkage of this EntityPoly.

        A flag to indicate whether the polymer contains at least  one monomer-to-monomer link different from that implied by  _entity_poly.type.  # noqa: E501

        :param nstd_linkage: The nstd_linkage of this EntityPoly.  # noqa: E501
        :type: str
        """
        allowed_values = ["n", "no", "y", "yes"]  # noqa: E501
        if nstd_linkage not in allowed_values:
            raise ValueError(
                "Invalid value for `nstd_linkage` ({0}), must be one of {1}"  # noqa: E501
                .format(nstd_linkage, allowed_values)
            )

        self._nstd_linkage = nstd_linkage

    @property
    def nstd_monomer(self):
        """Gets the nstd_monomer of this EntityPoly.  # noqa: E501

        A flag to indicate whether the polymer contains at least  one monomer that is not considered standard.  # noqa: E501

        :return: The nstd_monomer of this EntityPoly.  # noqa: E501
        :rtype: str
        """
        return self._nstd_monomer

    @nstd_monomer.setter
    def nstd_monomer(self, nstd_monomer):
        """Sets the nstd_monomer of this EntityPoly.

        A flag to indicate whether the polymer contains at least  one monomer that is not considered standard.  # noqa: E501

        :param nstd_monomer: The nstd_monomer of this EntityPoly.  # noqa: E501
        :type: str
        """
        allowed_values = ["n", "no", "y", "yes"]  # noqa: E501
        if nstd_monomer not in allowed_values:
            raise ValueError(
                "Invalid value for `nstd_monomer` ({0}), must be one of {1}"  # noqa: E501
                .format(nstd_monomer, allowed_values)
            )

        self._nstd_monomer = nstd_monomer

    @property
    def pdbx_seq_one_letter_code(self):
        """Gets the pdbx_seq_one_letter_code of this EntityPoly.  # noqa: E501

        Sequence of protein or nucleic acid polymer in standard one-letter                codes of amino acids or nucleotides. Non-standard amino                acids/nucleotides are represented by their Chemical                Component Dictionary (CCD) codes in                parenthesis. Deoxynucleotides are represented by the                specially-assigned 2-letter CCD codes in parenthesis,                with 'D' prefix added to their ribonucleotide                counterparts. For hybrid polymer, each residue is                represented by the code of its individual type. A                cyclic polymer is represented in linear sequence from                the chosen start to end.  A for Alanine or Adenosine-5'-monophosphate C for Cysteine or Cytidine-5'-monophosphate D for Aspartic acid E for Glutamic acid F for Phenylalanine G for Glycine or Guanosine-5'-monophosphate H for Histidine I for Isoleucine or Inosinic Acid L for Leucine K for Lysine M for Methionine N for Asparagine  or Unknown ribonucleotide O for Pyrrolysine P for Proline Q for Glutamine R for Arginine S for Serine T for Threonine U for Selenocysteine or Uridine-5'-monophosphate V for Valine W for Tryptophan Y for Tyrosine (DA) for 2'-deoxyadenosine-5'-monophosphate (DC) for 2'-deoxycytidine-5'-monophosphate (DG) for 2'-deoxyguanosine-5'-monophosphate (DT) for Thymidine-5'-monophosphate (MSE) for Selenomethionine (SEP) for Phosphoserine (PTO) for Phosphothreonine (PTR) for Phosphotyrosine (PCA) for Pyroglutamic acid (UNK) for Unknown amino acid (ACE) for Acetylation cap (NH2) for Amidation cap  # noqa: E501

        :return: The pdbx_seq_one_letter_code of this EntityPoly.  # noqa: E501
        :rtype: str
        """
        return self._pdbx_seq_one_letter_code

    @pdbx_seq_one_letter_code.setter
    def pdbx_seq_one_letter_code(self, pdbx_seq_one_letter_code):
        """Sets the pdbx_seq_one_letter_code of this EntityPoly.

        Sequence of protein or nucleic acid polymer in standard one-letter                codes of amino acids or nucleotides. Non-standard amino                acids/nucleotides are represented by their Chemical                Component Dictionary (CCD) codes in                parenthesis. Deoxynucleotides are represented by the                specially-assigned 2-letter CCD codes in parenthesis,                with 'D' prefix added to their ribonucleotide                counterparts. For hybrid polymer, each residue is                represented by the code of its individual type. A                cyclic polymer is represented in linear sequence from                the chosen start to end.  A for Alanine or Adenosine-5'-monophosphate C for Cysteine or Cytidine-5'-monophosphate D for Aspartic acid E for Glutamic acid F for Phenylalanine G for Glycine or Guanosine-5'-monophosphate H for Histidine I for Isoleucine or Inosinic Acid L for Leucine K for Lysine M for Methionine N for Asparagine  or Unknown ribonucleotide O for Pyrrolysine P for Proline Q for Glutamine R for Arginine S for Serine T for Threonine U for Selenocysteine or Uridine-5'-monophosphate V for Valine W for Tryptophan Y for Tyrosine (DA) for 2'-deoxyadenosine-5'-monophosphate (DC) for 2'-deoxycytidine-5'-monophosphate (DG) for 2'-deoxyguanosine-5'-monophosphate (DT) for Thymidine-5'-monophosphate (MSE) for Selenomethionine (SEP) for Phosphoserine (PTO) for Phosphothreonine (PTR) for Phosphotyrosine (PCA) for Pyroglutamic acid (UNK) for Unknown amino acid (ACE) for Acetylation cap (NH2) for Amidation cap  # noqa: E501

        :param pdbx_seq_one_letter_code: The pdbx_seq_one_letter_code of this EntityPoly.  # noqa: E501
        :type: str
        """

        self._pdbx_seq_one_letter_code = pdbx_seq_one_letter_code

    @property
    def pdbx_seq_one_letter_code_can(self):
        """Gets the pdbx_seq_one_letter_code_can of this EntityPoly.  # noqa: E501

        Canonical sequence of protein or nucleic acid polymer in standard                one-letter codes of amino acids or nucleotides,                corresponding to the sequence in                _entity_poly.pdbx_seq_one_letter_code. Non-standard                amino acids/nucleotides are represented by the codes of                their parents if parent is specified in                _chem_comp.mon_nstd_parent_comp_id, or by letter 'X' if                parent is not specified. Deoxynucleotides are                represented by their canonical one-letter codes of A,                C, G, or T.                 For modifications with several parent amino acids,         all corresponding parent amino acid codes will be listed         (ex. chromophores).  # noqa: E501

        :return: The pdbx_seq_one_letter_code_can of this EntityPoly.  # noqa: E501
        :rtype: str
        """
        return self._pdbx_seq_one_letter_code_can

    @pdbx_seq_one_letter_code_can.setter
    def pdbx_seq_one_letter_code_can(self, pdbx_seq_one_letter_code_can):
        """Sets the pdbx_seq_one_letter_code_can of this EntityPoly.

        Canonical sequence of protein or nucleic acid polymer in standard                one-letter codes of amino acids or nucleotides,                corresponding to the sequence in                _entity_poly.pdbx_seq_one_letter_code. Non-standard                amino acids/nucleotides are represented by the codes of                their parents if parent is specified in                _chem_comp.mon_nstd_parent_comp_id, or by letter 'X' if                parent is not specified. Deoxynucleotides are                represented by their canonical one-letter codes of A,                C, G, or T.                 For modifications with several parent amino acids,         all corresponding parent amino acid codes will be listed         (ex. chromophores).  # noqa: E501

        :param pdbx_seq_one_letter_code_can: The pdbx_seq_one_letter_code_can of this EntityPoly.  # noqa: E501
        :type: str
        """

        self._pdbx_seq_one_letter_code_can = pdbx_seq_one_letter_code_can

    @property
    def pdbx_sequence_evidence_code(self):
        """Gets the pdbx_sequence_evidence_code of this EntityPoly.  # noqa: E501

        Evidence for the assignment of the polymer sequence.  # noqa: E501

        :return: The pdbx_sequence_evidence_code of this EntityPoly.  # noqa: E501
        :rtype: str
        """
        return self._pdbx_sequence_evidence_code

    @pdbx_sequence_evidence_code.setter
    def pdbx_sequence_evidence_code(self, pdbx_sequence_evidence_code):
        """Sets the pdbx_sequence_evidence_code of this EntityPoly.

        Evidence for the assignment of the polymer sequence.  # noqa: E501

        :param pdbx_sequence_evidence_code: The pdbx_sequence_evidence_code of this EntityPoly.  # noqa: E501
        :type: str
        """
        allowed_values = ["depositor provided", "derived from coordinates"]  # noqa: E501
        if pdbx_sequence_evidence_code not in allowed_values:
            raise ValueError(
                "Invalid value for `pdbx_sequence_evidence_code` ({0}), must be one of {1}"  # noqa: E501
                .format(pdbx_sequence_evidence_code, allowed_values)
            )

        self._pdbx_sequence_evidence_code = pdbx_sequence_evidence_code

    @property
    def pdbx_strand_id(self):
        """Gets the pdbx_strand_id of this EntityPoly.  # noqa: E501

        The PDB strand/chain id(s) corresponding to this polymer entity.  # noqa: E501

        :return: The pdbx_strand_id of this EntityPoly.  # noqa: E501
        :rtype: str
        """
        return self._pdbx_strand_id

    @pdbx_strand_id.setter
    def pdbx_strand_id(self, pdbx_strand_id):
        """Sets the pdbx_strand_id of this EntityPoly.

        The PDB strand/chain id(s) corresponding to this polymer entity.  # noqa: E501

        :param pdbx_strand_id: The pdbx_strand_id of this EntityPoly.  # noqa: E501
        :type: str
        """

        self._pdbx_strand_id = pdbx_strand_id

    @property
    def pdbx_target_identifier(self):
        """Gets the pdbx_target_identifier of this EntityPoly.  # noqa: E501

        For Structural Genomics entries, the sequence's target identifier registered at the TargetTrack database.  # noqa: E501

        :return: The pdbx_target_identifier of this EntityPoly.  # noqa: E501
        :rtype: str
        """
        return self._pdbx_target_identifier

    @pdbx_target_identifier.setter
    def pdbx_target_identifier(self, pdbx_target_identifier):
        """Sets the pdbx_target_identifier of this EntityPoly.

        For Structural Genomics entries, the sequence's target identifier registered at the TargetTrack database.  # noqa: E501

        :param pdbx_target_identifier: The pdbx_target_identifier of this EntityPoly.  # noqa: E501
        :type: str
        """

        self._pdbx_target_identifier = pdbx_target_identifier

    @property
    def rcsb_artifact_monomer_count(self):
        """Gets the rcsb_artifact_monomer_count of this EntityPoly.  # noqa: E501

        Number of regions in the sample sequence identified as expression tags, linkers, or  cloning artifacts.  # noqa: E501

        :return: The rcsb_artifact_monomer_count of this EntityPoly.  # noqa: E501
        :rtype: int
        """
        return self._rcsb_artifact_monomer_count

    @rcsb_artifact_monomer_count.setter
    def rcsb_artifact_monomer_count(self, rcsb_artifact_monomer_count):
        """Sets the rcsb_artifact_monomer_count of this EntityPoly.

        Number of regions in the sample sequence identified as expression tags, linkers, or  cloning artifacts.  # noqa: E501

        :param rcsb_artifact_monomer_count: The rcsb_artifact_monomer_count of this EntityPoly.  # noqa: E501
        :type: int
        """

        self._rcsb_artifact_monomer_count = rcsb_artifact_monomer_count

    @property
    def rcsb_conflict_count(self):
        """Gets the rcsb_conflict_count of this EntityPoly.  # noqa: E501

        Number of monomer conflicts relative to the reference sequence.  # noqa: E501

        :return: The rcsb_conflict_count of this EntityPoly.  # noqa: E501
        :rtype: int
        """
        return self._rcsb_conflict_count

    @rcsb_conflict_count.setter
    def rcsb_conflict_count(self, rcsb_conflict_count):
        """Sets the rcsb_conflict_count of this EntityPoly.

        Number of monomer conflicts relative to the reference sequence.  # noqa: E501

        :param rcsb_conflict_count: The rcsb_conflict_count of this EntityPoly.  # noqa: E501
        :type: int
        """

        self._rcsb_conflict_count = rcsb_conflict_count

    @property
    def rcsb_deletion_count(self):
        """Gets the rcsb_deletion_count of this EntityPoly.  # noqa: E501

        Number of monomer deletions relative to the reference sequence.  # noqa: E501

        :return: The rcsb_deletion_count of this EntityPoly.  # noqa: E501
        :rtype: int
        """
        return self._rcsb_deletion_count

    @rcsb_deletion_count.setter
    def rcsb_deletion_count(self, rcsb_deletion_count):
        """Sets the rcsb_deletion_count of this EntityPoly.

        Number of monomer deletions relative to the reference sequence.  # noqa: E501

        :param rcsb_deletion_count: The rcsb_deletion_count of this EntityPoly.  # noqa: E501
        :type: int
        """

        self._rcsb_deletion_count = rcsb_deletion_count

    @property
    def rcsb_entity_polymer_type(self):
        """Gets the rcsb_entity_polymer_type of this EntityPoly.  # noqa: E501

        A coarse-grained polymer entity type.  # noqa: E501

        :return: The rcsb_entity_polymer_type of this EntityPoly.  # noqa: E501
        :rtype: str
        """
        return self._rcsb_entity_polymer_type

    @rcsb_entity_polymer_type.setter
    def rcsb_entity_polymer_type(self, rcsb_entity_polymer_type):
        """Sets the rcsb_entity_polymer_type of this EntityPoly.

        A coarse-grained polymer entity type.  # noqa: E501

        :param rcsb_entity_polymer_type: The rcsb_entity_polymer_type of this EntityPoly.  # noqa: E501
        :type: str
        """
        allowed_values = ["DNA", "NA-hybrid", "Other", "Protein", "RNA"]  # noqa: E501
        if rcsb_entity_polymer_type not in allowed_values:
            raise ValueError(
                "Invalid value for `rcsb_entity_polymer_type` ({0}), must be one of {1}"  # noqa: E501
                .format(rcsb_entity_polymer_type, allowed_values)
            )

        self._rcsb_entity_polymer_type = rcsb_entity_polymer_type

    @property
    def rcsb_insertion_count(self):
        """Gets the rcsb_insertion_count of this EntityPoly.  # noqa: E501

        Number of monomer insertions relative to the reference sequence.  # noqa: E501

        :return: The rcsb_insertion_count of this EntityPoly.  # noqa: E501
        :rtype: int
        """
        return self._rcsb_insertion_count

    @rcsb_insertion_count.setter
    def rcsb_insertion_count(self, rcsb_insertion_count):
        """Sets the rcsb_insertion_count of this EntityPoly.

        Number of monomer insertions relative to the reference sequence.  # noqa: E501

        :param rcsb_insertion_count: The rcsb_insertion_count of this EntityPoly.  # noqa: E501
        :type: int
        """

        self._rcsb_insertion_count = rcsb_insertion_count

    @property
    def rcsb_mutation_count(self):
        """Gets the rcsb_mutation_count of this EntityPoly.  # noqa: E501

        Number of engineered mutations engineered in the sample sequence.  # noqa: E501

        :return: The rcsb_mutation_count of this EntityPoly.  # noqa: E501
        :rtype: int
        """
        return self._rcsb_mutation_count

    @rcsb_mutation_count.setter
    def rcsb_mutation_count(self, rcsb_mutation_count):
        """Sets the rcsb_mutation_count of this EntityPoly.

        Number of engineered mutations engineered in the sample sequence.  # noqa: E501

        :param rcsb_mutation_count: The rcsb_mutation_count of this EntityPoly.  # noqa: E501
        :type: int
        """

        self._rcsb_mutation_count = rcsb_mutation_count

    @property
    def rcsb_non_std_monomer_count(self):
        """Gets the rcsb_non_std_monomer_count of this EntityPoly.  # noqa: E501

        Number of non-standard monomers in the sample sequence.  # noqa: E501

        :return: The rcsb_non_std_monomer_count of this EntityPoly.  # noqa: E501
        :rtype: int
        """
        return self._rcsb_non_std_monomer_count

    @rcsb_non_std_monomer_count.setter
    def rcsb_non_std_monomer_count(self, rcsb_non_std_monomer_count):
        """Sets the rcsb_non_std_monomer_count of this EntityPoly.

        Number of non-standard monomers in the sample sequence.  # noqa: E501

        :param rcsb_non_std_monomer_count: The rcsb_non_std_monomer_count of this EntityPoly.  # noqa: E501
        :type: int
        """

        self._rcsb_non_std_monomer_count = rcsb_non_std_monomer_count

    @property
    def rcsb_non_std_monomers(self):
        """Gets the rcsb_non_std_monomers of this EntityPoly.  # noqa: E501

        Unique list of non-standard monomer chemical component identifiers in the sample sequence.  # noqa: E501

        :return: The rcsb_non_std_monomers of this EntityPoly.  # noqa: E501
        :rtype: list[str]
        """
        return self._rcsb_non_std_monomers

    @rcsb_non_std_monomers.setter
    def rcsb_non_std_monomers(self, rcsb_non_std_monomers):
        """Sets the rcsb_non_std_monomers of this EntityPoly.

        Unique list of non-standard monomer chemical component identifiers in the sample sequence.  # noqa: E501

        :param rcsb_non_std_monomers: The rcsb_non_std_monomers of this EntityPoly.  # noqa: E501
        :type: list[str]
        """

        self._rcsb_non_std_monomers = rcsb_non_std_monomers

    @property
    def rcsb_prd_id(self):
        """Gets the rcsb_prd_id of this EntityPoly.  # noqa: E501

        For polymer BIRD molecules the BIRD identifier for the entity.  # noqa: E501

        :return: The rcsb_prd_id of this EntityPoly.  # noqa: E501
        :rtype: str
        """
        return self._rcsb_prd_id

    @rcsb_prd_id.setter
    def rcsb_prd_id(self, rcsb_prd_id):
        """Sets the rcsb_prd_id of this EntityPoly.

        For polymer BIRD molecules the BIRD identifier for the entity.  # noqa: E501

        :param rcsb_prd_id: The rcsb_prd_id of this EntityPoly.  # noqa: E501
        :type: str
        """

        self._rcsb_prd_id = rcsb_prd_id

    @property
    def rcsb_sample_sequence_length(self):
        """Gets the rcsb_sample_sequence_length of this EntityPoly.  # noqa: E501

        The monomer length of the sample sequence.  # noqa: E501

        :return: The rcsb_sample_sequence_length of this EntityPoly.  # noqa: E501
        :rtype: int
        """
        return self._rcsb_sample_sequence_length

    @rcsb_sample_sequence_length.setter
    def rcsb_sample_sequence_length(self, rcsb_sample_sequence_length):
        """Sets the rcsb_sample_sequence_length of this EntityPoly.

        The monomer length of the sample sequence.  # noqa: E501

        :param rcsb_sample_sequence_length: The rcsb_sample_sequence_length of this EntityPoly.  # noqa: E501
        :type: int
        """

        self._rcsb_sample_sequence_length = rcsb_sample_sequence_length

    @property
    def type(self):
        """Gets the type of this EntityPoly.  # noqa: E501

        The type of the polymer.  # noqa: E501

        :return: The type of this EntityPoly.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this EntityPoly.

        The type of the polymer.  # noqa: E501

        :param type: The type of this EntityPoly.  # noqa: E501
        :type: str
        """
        allowed_values = ["cyclic-pseudo-peptide", "other", "peptide nucleic acid", "polydeoxyribonucleotide", "polydeoxyribonucleotide/polyribonucleotide hybrid", "polypeptide(D)", "polypeptide(L)", "polyribonucleotide"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"  # noqa: E501
                .format(type, allowed_values)
            )

        self._type = type

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(EntityPoly, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, EntityPoly):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
